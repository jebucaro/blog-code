import json
import logging
import time
from typing import Any

from google import genai
from google.genai import types

from models import KnowledgeGraph, ExecutiveSummary, ExtractionResult
from settings import Settings
from errors import (
    APIUnavailableError,
    ExtractionError,
    MissingAPIKeyError,
    NetworkError,
    ParsingError,
    RateLimitError,
    TokenLimitError,
    UnknownAPIError,
    default_user_messages,
)

logger = logging.getLogger(__name__)

SYSTEM_PROMPT = """
        # Knowledge Graph Instructions for Gemini
        ## 1. Overview
        You are a top-tier algorithm designed for extracting information in structured formats to build a knowledge graph.
        Try to capture as much information from the text as possible without sacrificing accuracy. Do not add any information that is not explicitly mentioned in the text.
        - Nodes represent entities and concepts.
        - The aim is to achieve simplicity and clarity in the knowledge graph.
        - The input text may already be an executive summary with
            explicit sections and entity names. Regardless of style,
            extract as many accurate entities and relationships as possible.

    ## 2. Node Fields
    The output Node must have two fields: `id` and `type`. DO NOT include a `label` field.

    ### ID (The Standardized Key)
    - **Formatting:** Node `id` MUST be generated by taking the human-readable text, converting it to **lowercase**, and replacing all spaces/special characters with **underscores (_)**.
    - **Crucial Rule for Numbers:** For numeric concepts (like "34 years old"), the ID must be prefixed with a meaningful string and use underscores.
    - **Example:** For "34 years old", the ID must be 'age_34'. For "Alex Johnson", the ID must be 'alex_johnson'.
    - **Constraints:** Never utilize standalone integers as node IDs.

    ### Type (The General Category)
    - **Formatting:** Node `type` must be basic, elementary, and **lowercase** (e.g., 'person', 'occupation', 'hobby').
    - **Consistency:** Always use basic types for node `type`. Avoid specific types like 'mathematician'.

    ## 3. Relationships
    - **Type Formatting:** Relationship `type` MUST be general, timeless, and **UPPERCASE** using **underscores (_)** as separators.
    - **Example:** Use 'WORKS_AS' instead of 'BECAME_PROFESSOR'.
    - **CRITICAL VALIDATION RULE:** Every relationship's `source_node_id` and `target_node_id` MUST reference a node `id` that exists in the nodes list you create.
    - **Before creating a relationship:** Verify that BOTH the source and target nodes have been extracted as nodes. If a node doesn't exist, you MUST create it first.
    - **Completeness:** If you reference an entity in a relationship, that entity MUST appear in the nodes list with a properly formatted `id`.

    ## 4. Coreference Resolution
    - **Consistency:** Ensure the generated **`id`** is consistent across all nodes and relationships.
    - **Example:** For "Alex Johnson" (referred to as "he"), the `id` should always be 'alex_johnson' in BOTH the nodes list AND all relationships.
    - **Apply ID formatting consistently:** When you reference an entity in a relationship, convert it to the same lowercase_underscore format you used for the node `id`.

    ## 5. Two-Pass Extraction Strategy
    To ensure completeness and consistency:
    1. **First Pass:** Extract all entities and concepts as nodes with properly formatted `id` and `type`.
    2. **Second Pass:** Create relationships, ensuring every `source_node_id` and `target_node_id` matches an `id` from your nodes list.
    3. **Validation:** Before finalizing, verify that every relationship references existing node IDs.

    ## 6. Strict Compliance
    Adhere to the rules strictly. Non-compliance will result in termination.
    - Every relationship MUST have valid source and target nodes
    - Node IDs must be consistent between nodes and relationships
    - Use the same ID formatting rules everywhere
"""


SUMMARY_SYSTEM_PROMPT = """
You are an expert executive assistant.

Goal:
- Read the input text and produce a concise, executive-level summary
    that is easy for a human to scan and ALSO easy for an automated
    system to turn into a knowledge graph later.
- You MUST NOT create or output a knowledge graph, only structured text.

Audience:
- A busy executive who wants the big picture quickly.
- A downstream system that will parse the summary text to extract
    entities and relationships.

General requirements:
- Be concise but information-dense (about 1–4 short paragraphs total).
- Preserve key proper nouns (people, teams, organizations, products,
    projects, places) instead of replacing them with vague pronouns.
- Preserve important dates, numbers, and quantities exactly when given.
- Use clear, literal language; avoid metaphors or creative rewrites.
- Do not invent facts or speculate beyond the source text.

Text structure (very important):
- Organize the `summary` text into the following labeled sections,
    in this exact order, using these headings:

    1. "Overview:"
    2. "Key Entities and Roles:"
    3. "Decisions and Actions:"
    4. "Risks and Constraints:"
    5. "Dependencies and Relationships:"

- Each heading should be followed by 1–3 concise sentences.
- When possible, write sentences in the pattern:
    "<ENTITY A> <verb phrase> <ENTITY B> ..." to make relationships explicit.
    Examples:
    - "Acme Corp leads the integration with Vendor X."
    - "The Data Platform team depends on the API team for authentication."
    - "Regulation Y imposes a constraint on cross-border data transfers."

Style constraints:
- Minimize the use of pronouns like "it", "they", "this".
    Prefer repeating the concrete entity names for clarity.
- Prefer simple verbs like "is", "has", "leads", "owns", "manages",
    "depends on", "affects", "causes", "uses", "blocks", "supports".
- Avoid low-level implementation details unless they are essential
    to understanding a decision, risk, or dependency.

JSON output format:
- Return a JSON object matching the provided schema.
- The `summary` field must contain the full structured text with the
    five headings above, in plain text.
- Optionally include `key_points`:
    - If present, include 3–7 bullet-style strings.
    - Each key point should mention concrete entities and facts
        (for example: "Acme Corp will deliver the first release in Q3
         with support from the Data Platform team").
"""


class GeminiExtractor:
    """Extract knowledge graphs from text using Google Gemini API."""

    def __init__(self, settings: Settings | None = None, api_key: str | None = None):
        """
        Initialize the GeminiExtractor

        Args:
            settings (Settings | None): Configuration object containing API key and model name.
            api_key (str | None): Direct API key string. If provided, it overrides config.
        """
        self.settings = settings or Settings()

        key_to_use = api_key or self.settings.gemini_api_key
        messages = default_user_messages()
        if not key_to_use:
            # Explicit, user-friendly error for missing key
            raise MissingAPIKeyError(
                user_message=messages["missing_api_key"],
                detail="Gemini API key must be provided via argument or Settings.gemini_api_key.",
            )

        self.client = genai.Client(api_key=key_to_use)
        self.kg_config = types.GenerateContentConfig(
            system_instruction=SYSTEM_PROMPT,
            response_mime_type="application/json",
            response_schema=KnowledgeGraph.model_json_schema(),
        )
        self.summary_config = types.GenerateContentConfig(
            system_instruction=SUMMARY_SYSTEM_PROMPT,
            response_mime_type="application/json",
            response_schema=ExecutiveSummary.model_json_schema(),
        )

        logger.info("Initialized Gemini extractor")

    def extract(self, text: str) -> KnowledgeGraph:
        """
        Extract a knowledge graph from the provided text.

        Args:
            text (str): The input text to extract the knowledge graph from.

        Returns:
            KnowledgeGraph: The extracted knowledge graph.
        """

        if not text or not text.strip():
            raise ValueError("Input text must be a non-empty string.")

        # NOTE: API-key presence is not enforced here to
        # allow free-tier / key-less usage when supported
        # by the underlying Google Gemini service.

        json_data: str | None = None
        messages = default_user_messages()

        try:
            start_time = time.time()
            response = self.client.models.generate_content(
                model=self.settings.gemini_model,
                contents=text,
                config=self.kg_config,
            )
            elapsed_time = time.time() - start_time
            logger.info(f"Gemini API responded in {elapsed_time:.2f}s")

            # Check if response was truncated or incomplete
            if hasattr(response, "candidates") and response.candidates:
                candidate = response.candidates[0]
                finish_reason: Any = getattr(candidate, "finish_reason", None)

                if finish_reason and finish_reason != "STOP":
                    logger.warning(f"Response may be incomplete. Finish reason: {finish_reason}")

            # Get text from response
            try:
                json_data = response.text
            except Exception as e:  # Fallback for older/changed SDKs
                logger.error(f"Error accessing response.text: {e}")
                if hasattr(response, "candidates") and response.candidates:
                    candidate = response.candidates[0]
                    content = getattr(candidate, "content", None)
                    parts = getattr(content, "parts", None) if content is not None else None
                    if parts and hasattr(parts[0], "text"):
                        json_data = parts[0].text

            if not json_data:
                # Treat empty responses as token/size or service issues
                raise TokenLimitError(
                    user_message=messages["token_limit"],
                    detail="Empty response from Gemini API; likely token or size limit.",
                )

            # Check for MAX_TOKENS after retrieving text
            if hasattr(response, "candidates") and response.candidates:
                finish_reason = response.candidates[0].finish_reason
                if finish_reason == "MAX_TOKENS":
                    logger.error(f"Response truncated at {len(json_data)} characters")
                    logger.error(f"Last 200 chars: {json_data[-200:]}")
                    raise TokenLimitError(
                        user_message=messages["token_limit"],
                        detail=(
                            f"Response exceeded maximum token limit (finish_reason=MAX_TOKENS, chars={len(json_data)})."
                        ),
                    )

            parsed_data = json.loads(json_data)

            # Log raw response for debugging (minified)
            logger.debug(f"Raw Gemini response: {json.dumps(parsed_data, separators=(',', ':'))}")

            knowledge_graph = KnowledgeGraph.model_validate(parsed_data)

            logger.info(
                "Successfully extracted knowledge graph with %d nodes and %d relationships",
                len(knowledge_graph.nodes),
                len(knowledge_graph.relationships),
            )
            return knowledge_graph

        except json.JSONDecodeError as e:
            logger.error("Failed to decode JSON response from Gemini: %s", e)
            if json_data is not None:
                logger.error("Response length: %d characters", len(json_data))
                logger.error("Last 500 chars of response: %s", json_data[-500:])
            raise ParsingError(
                user_message=messages["parsing"],
                detail=str(e),
            ) from e

        except ParsingError:
            # Already mapped; just propagate.
            raise

        except TokenLimitError:
            # Already mapped; just propagate.
            raise

        except Exception as e:
            # Map common SDK/network-ish errors to user-friendly classes.
            detail = str(e)
            lowered = detail.lower()

            # Very lightweight heuristic mapping without depending on
            # internal Google SDK exception types.
            if any(code in lowered for code in ("unavailable", "503", "502")):
                mapped: ExtractionError = APIUnavailableError(
                    user_message=messages["api_unavailable"],
                    detail=detail,
                )
            elif any(term in lowered for term in ("rate limit", "quota", "429")):
                mapped = RateLimitError(
                    user_message=messages["rate_limited"],
                    detail=detail,
                )
            elif any(term in lowered for term in ("timeout", "timed out", "connection", "network")):
                mapped = NetworkError(
                    user_message=messages["network"],
                    detail=detail,
                )
            else:
                mapped = UnknownAPIError(
                    user_message=messages["unknown"],
                    detail=detail,
                )

            logger.error("Extraction failed: %s", mapped)
            raise mapped from e

    def summarize(self, text: str) -> ExecutiveSummary:
        """Create an executive summary from the provided text using Gemini.

        The result is structured according to the ExecutiveSummary model.
        """

        if not text or not text.strip():
            raise ValueError("Input text must be a non-empty string.")

        json_data: str | None = None
        messages = default_user_messages()

        try:
            start_time = time.time()
            response = self.client.models.generate_content(
                model=self.settings.gemini_model,
                contents=text,
                config=self.summary_config,
            )
            elapsed_time = time.time() - start_time
            logger.info(f"Gemini summary responded in {elapsed_time:.2f}s")

            if hasattr(response, "candidates") and response.candidates:
                candidate = response.candidates[0]
                finish_reason: Any = getattr(candidate, "finish_reason", None)
                if finish_reason and finish_reason != "STOP":
                    logger.warning(f"Summary response may be incomplete. Finish reason: {finish_reason}")

            try:
                json_data = response.text
            except Exception as e:  # pragma: no cover - defensive
                logger.error(f"Error accessing summary response.text: {e}")
                if hasattr(response, "candidates") and response.candidates:
                    candidate = response.candidates[0]
                    content = getattr(candidate, "content", None)
                    parts = getattr(content, "parts", None) if content is not None else None
                    if parts and hasattr(parts[0], "text"):
                        json_data = parts[0].text

            if not json_data:
                raise TokenLimitError(
                    user_message=messages["token_limit"],
                    detail="Empty response from Gemini summary API; likely token or size limit.",
                )

            if hasattr(response, "candidates") and response.candidates:
                finish_reason = response.candidates[0].finish_reason
                if finish_reason == "MAX_TOKENS":
                    logger.error(f"Summary response truncated at {len(json_data)} characters")
                    logger.error(f"Summary last 200 chars: {json_data[-200:]}")
                    raise TokenLimitError(
                        user_message=messages["token_limit"],
                        detail=(
                            "Summary response exceeded maximum token limit "
                            f"(finish_reason=MAX_TOKENS, chars={len(json_data)})."
                        ),
                    )

            parsed_data = json.loads(json_data)
            logger.debug(f"Raw Gemini summary response: {json.dumps(parsed_data, separators=(',', ':'))}")

            summary = ExecutiveSummary.model_validate(parsed_data)
            logger.info("Successfully generated executive summary")
            return summary

        except json.JSONDecodeError as e:
            logger.error("Failed to decode JSON summary response from Gemini: %s", e)
            if json_data is not None:
                logger.error("Summary response length: %d characters", len(json_data))
                logger.error("Summary last 500 chars of response: %s", json_data[-500:])
            raise ParsingError(
                user_message=messages["parsing"],
                detail=str(e),
            ) from e

        except ParsingError:
            raise

        except TokenLimitError:
            raise

        except Exception as e:  # pragma: no cover - error mapping
            detail = str(e)
            lowered = detail.lower()

            if any(code in lowered for code in ("unavailable", "503", "502")):
                mapped: ExtractionError = APIUnavailableError(
                    user_message=messages["api_unavailable"],
                    detail=detail,
                )
            elif any(term in lowered for term in ("rate limit", "quota", "429")):
                mapped = RateLimitError(
                    user_message=messages["rate_limited"],
                    detail=detail,
                )
            elif any(term in lowered for term in ("timeout", "timed out", "connection", "network")):
                mapped = NetworkError(
                    user_message=messages["network"],
                    detail=detail,
                )
            else:
                mapped = UnknownAPIError(
                    user_message=messages["unknown"],
                    detail=detail,
                )

            logger.error("Summary generation failed: %s", mapped)
            raise mapped from e

    def extract_with_summary(self, text: str, use_summary_for_kg: bool = True) -> ExtractionResult:
        """High-level helper that performs summarization and KG extraction.

        Args:
            text: Original input text.
            use_summary_for_kg: If True, build the KG from the summary
                text; otherwise, build it directly from the full text.
        """

        summary: ExecutiveSummary | None = None

        # Always produce a summary so the UI can show it.
        summary = self.summarize(text)

        if use_summary_for_kg:
            kg_input = summary.summary
        else:
            kg_input = text

        knowledge_graph = self.extract(kg_input)
        return ExtractionResult(summary=summary, knowledge_graph=knowledge_graph)

    def close(self):
        """Properly close the Gemini client to avoid cleanup errors."""
        try:
            if hasattr(self, 'client') and self.client:
                self.client.close()
        except Exception:
            pass  # Ignore errors during cleanup

    def __del__(self):
        """Destructor to ensure the client is closed."""
        self.close()
